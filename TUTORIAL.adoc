= Unquery-lite tutorial
:sectnums:
Sela Mador-Haim
:toc:

== Introduction

~Q (pronounced un-query) is a language for querying and transforming structured documents. It was originally developed 
for http://www.xcitedb.com[XCiteDB], a fast and reliable document-oriented noSQL database for storing structured documents,
suppoting XML and JSON, with temporal versionning and branches.

unQuery-lite is a command line tool for running ~Q queries directly on json files, without loading it to a database. It can read one or multiple json files and a ~Q query, and produce a new json file with the result of the query. This tutorial shows how to write ~Q queries and use them with unQuery-lite. It will not show parts of the language that are supported only by XCiteDB, such as reading XML, or querying across multiple versions and branches.

=== ~Q Language Overview

~Q is a powerful and easy to use querying language. For JSON, it can be used to:

* Extract information from a JSON file.
* Collect information from multiple JSON files.
* Transform a JSON file, change the way it is organized, add or remove information.
* Perform calculations on json data, including aggregation.

One of the key properties of ~Q is that each query is formatted as json, and the structure of the result always corresponds to the structure of the query.
You can think about ~Q (or at least simple ~Q queries) as a template for the result, and structure the query according to the way you want the result to look.
As we would show you in this tutorial, this is one of ~Q's key strengths. 

== Simple example: employee data

=== Data structure

As an introdction to ~Q, we'll start with a simple dataset. We have multiple files with information about employees in some company. Those files are stored in 
the directory `tutorial-samples/employees`. Each file contains information about one employee in this fictituous company, and looks like:
```
{
    "FirstName":"John",
    "LastName":"Smith",
    "Title":"CTO",
    "Salary":320000,
    "Address": {
	"Street":"123 Oak Street",
	"City":"Austin",
	"State":"TX",
	"Zip":78705
    },
    "Dependants": [
	{"FirstName":"Jane",
	 "LastName":"Smith",
	 "Relation":"Wife"
	},
	{"FirstName":"Jake",
	 "LastName":"Smith",
	 "Relation":"Child"
	},
	{"FirstName":"Jenna",
	 "LastName":"Smith",
	 "Relation":"Child"
	}
    ]
}
```

=== Simple queries

Suppose we want to extract the field `FirstName` from employee1.json. All we need to do is to write a query file `query1.unq` (the extension is just a convention, and you can choose any name) with the following text:
```
"FirstNames"
```

Assuming `unQLite` is in your search path, you can write:
```shell
unQLite -f query1.unq employee1.json
```

And you'll get the result:
```
"John"
```

For such a simple query, you may want to write the query directly in the command line, instead of storing the query in a file. You can do this with the `-c` option:
```shell
unQLite -c '"FirstName"' employee1.json
```

Note that we use single quotes around the query, so that all the special characters (including the double quotes in this case) would be passed to the program.

But wait! Didn't I just say earlier that each query in ~Q is a json file? This doesn't look very much like json. But in fact, a string literal (in double quotes) is a legal json value. In the simplest cases, where we just want to extract a single value, this is all we need. When we want to extract a specific field, all we need to do is to write the field name in quotes. If the field is in a nested object, we can use the syntax `field1.field2`. For example, try query2.unq:
```
"Address.City"
```
And you'll get the response: `"Austin"`.

Similarly, you can extract information from a specific element inside an array. For example, to get the first name of the first dependant, you can write:
```
"Dependants[0].FirstName"
```

And get the result: `"Jane"`.

Note that in case we have any characters other than alphanumeric and underscore, we need to enclose it in backticks. For example, if the field name was `"First Name"`, we should write:
```
"`First Name`"
```

Instead of just extracting a single field, we can specify multiple fields we want to extract, as an object:
```
{
  "fullname": "FirstName++' '++LastName",
  "title":"Title",
  "city": "Address.City"
 }
```
 
 This looks much more like what we think of as json. And it shows how ~Q can express queries as templates. The result would be:
```
 {
    "fullname": "John Smith",
    "title": "CTO",
    "city": "Austin"
}
```

Two things to note here. First, the keys in this object don't have to match the keys in the original json. We renamed `Title` as `title`, etc. Also, notice that we used an expression that connects first and last name into a single string, with the concatenation operator, `++`.

We can also create new nested objects. For example, if we want to group title and salary together inside an "employment" object, we can write the query:
```
{
  "name": "FirstName++' '++LastName",
  "employment": {
     "title":"Title",
     "salary":"Salary"
  }
}
```

=== Collecting information

Suppose we want to collect information from multiple json files. We can try, for example, to run the query `"FirstName"` on all the employees:
```shell
unQLite -c '"FirstName"' *.json
```

Oh no! This is not what we expected. The result is only `"John"` again. What happened to all the other names? Recall that the output 
structure should correspond to the query structure. In this case, we expect to get an array of names. So we need to specify an array in the query
with `[...]`:
```
["FirstName"]
```

Now we get an array with all the first names. In general, an array in ~Q contains a single element, which could be either a string literal or a more complex value (an object, or another array etc.). Once the query is evluated, the array is expended to include all the values from all the files we process. Without square brackets, all we can expect is a single value (or a single object).

The array we get with the above query is unsorted. We can sort the results by adding a sorting directive. For example, to sort the first names in ascending order, we can write:
```
["FirstName@ascending"]
```

Similarly, we can use `@descending` and also `@unique_ascending` and `@unique_descending` to sort and remove duplicates.

We can also use conditions to filter the results (similar to `WHERE` clauses in SQL. There are multiple ways to specify a condition in ~Q. One of them is a predicate at the end of the value expression, with `?` followed by a condition. For example, to get the last name of all employees earning over 200,000, we can write:
```
["LastName?Salary>200000"]
```

Now, suppose we want to get first and last name and title for all developers. We can write:
```
[{
	"FirstName":"FirstName",
	"LastName":"LastName",
	"Title":"Title contains 'Developer'"
}]
```

Note that in this case, we didn't use the `?`. When we have a constraint on a value we display, we can write the costraint directly on that value.

Another way to filter the results is using the `#if` directive. 
For example, suppose we want to list employees with three dependants or more. We can use the query:
```
[{
	"#if":"$size(Dependants)>=3",
	"FirstName":"FirstName",
	"LastName":"LastName"
}]
```

The function `$size` returns the size of an array. At this point, you might ask: what if we want to filter by the number of children, 
and not all dependants? Can we do this? Of course we can. We'll get back to this later.

Suppose we want to collect all the information we have on employees, and not just specific fields. We can do this using the dot
operator. `"."` stands for the current value we handle. If we didn't use any context modifiers (more on this later), it's the entire
file. So the query:
```
["."]
```

Would create one big array, containing all employee data.

We can also use aggregation functions to calculate all sort of values such as min, max, sum, average etc. For example:
```
"$avg(Salary)"
```

Would return the average salary in the company.

```
"$count"
```

Would return the total number of employees. We can also combine aggregation functions with predicates. This would make
the function do the aggregation only for elements where the condition is true. For example:
```
$count?Salary>200000
```

Would return the total number of employees with salary greater than 200,000.

=== Context modifiers

Context modifiers are one of the most powerful and versatile mechanisms in ~Q. The context is the path we use in different places
in the query. By default, the context is an empty path, and all fields are relative to the top node, but we can change it
with a context modifier. For example, suppose we want to get the full address in one string. We can do it with the expression:
```
[{
	"FullAddress":"Address.Street++' '++Address.City++' '++Address.State++', '++Address.Zip"
}]
```

But if we change the context to `Address`, we no longer have to write it over and over in the expression. We change the context
using a context modifier, which is an expression following a colon in the key name:
```
[{
	"FullAddress:Address":"Street++' '++City++' '++State++', '++Zip"
}]
```

Context modifiers can do more than just changing the path. It can be used to iterate over multiple paths. We do that using Two
square brackets without any index inside it. If, for example, we want to get all employees childrens' names, we can run the
query:

```
{
	"Childen:Dependants[]?Relation='Child'" :
	[
		"FirstName++' '++LastName"
	]
}
```

In this case, we also used a predicate following the context modifier. In this query, it would have the same effect as adding
a predicate after the value expression. Also note that the result here is a single array containing all children for all employees.
If we added outer square brachets, this would change, and we'll have a seperate array of chilren for each employee:
```
[{
	"Childen:Dependants[]?Relation='Child'" :
	[
		"FirstName++' '++LastName"
	]
}]
```

Predicates can be used to control which elements to traverse in other ways. For example, we can use the `$index` function to traverse
only certain elements in the array:
```
[{
	"Dependants:Dependants[]?$index<2":
	[
		"FirstName++' '++LastName"
	]
}]
```

We can also combine multiple context modifiers with the `|` (or) operator. For example, if we want to collect both employee names
and dependant names into a single array, we can run the query:
```
{
        "names:.|Dependants[]":
        [
                "FirstName++' '++LastName"
        ]
}
```

Note that the context here is either `.` (the current path) or `Dependants[]`.

When aggregation functions are within a context modifier, those functions can be used to aggregate inside an array. For example,
if we want the number of children for each employee, we can do:
```
[{
        "FirstName:" : ".",
        "LastName:" : ".",
        "NumOfChildren:Dependants[]":"$count?Relation='Child'"
}]
```

In the above example, note the use of `:` without any context modifier following the colon. In this case, the context modifier is
the same as the field names, so `"FirstName:"` is the same as `"FirstName:FirstName"`.

This brings us to the question we had earlier in this tutorial: how do we filter employees based on their number of children?
We can do it using context modifiers and aggregation function, as in the following query:
```
[{
	"#if:Dependants[]?Relation='Child'": "$count>1",
	"FirstName:" : ".",
	"LastName:" : "."
}]
```

Though ~Q allows using aggregation functions in conditions, as shown in the above example, note that this should be done with
caution, and it is not always possible. ~Q allows comparing aggregation functions with a constant literal (e.g. a number),
but does not allow comparing aggregation function with some field value in the json file.
