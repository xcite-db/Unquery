= Unquery-lite tutorial
:sectnums:
Sela Mador-Haim
:toc:

== Introduction

~Q (pronounced un-query) is a language for querying and transforming structured documents. It was originally developed 
for http://www.xcitedb.com[XCiteDB], a fast and reliable document-oriented noSQL database for storing structured documents,
suppoting XML and JSON, with temporal versionning and branches.

unQuery-lite is a command line tool for running ~Q queries directly on json files, without loading it to a database. It can read one or multiple json files and a ~Q query, and produce a new json file with the result of the query. This tutorial shows how to write ~Q queries and use them with unQuery-lite. It will not show parts of the language that are supported only by XCiteDB, such as reading XML, or querying across multiple versions and branches.

=== ~Q Language Overview

~Q is a powerful and easy to use querying language. For JSON, it can be used to:

* Extract information from a JSON file.
* Collect information from multiple JSON files.
* Transform a JSON file, change the way it is organized, add or remove information.
* Perform calculations on json data, including aggregation.

One of the key properties of ~Q is that each query is formatted as json, and the structure of the result always corresponds to the structure of the query.
You can think about ~Q (or at least simple ~Q queries) as a template for the result, and structure the query according to the way you want the result to look.
As we would show you in this tutorial, this is one of ~Q's key strengths. 

== Simple example: employee data

=== Data structure

As an introdction to ~Q, we'll start with a simple dataset. We have multiple files with information about employees in some company. Those files are stored in 
the directory `tutorial-samples/employees`. Each file contains information about one employee in this fictituous company, and looks like:
```
{
    "FirstName":"John",
    "LastName":"Smith",
    "Title":"CTO",
    "Salary":320000,
    "Address": {
	"Street":"123 Oak Street",
	"City":"Austin",
	"State":"TX",
	"Zip":78705
    },
    "Dependants": [
	{"FirstName":"Jane",
	 "LastName":"Smith",
	 "Relation":"Wife"
	},
	{"FirstName":"Jake",
	 "LastName":"Smith",
	 "Relation":"Child"
	},
	{"FirstName":"Jenna",
	 "LastName":"Smith",
	 "Relation":"Child"
	}
    ]
}
```

=== Simple queries

Suppose we want to extract the field `FirstName` from employee1.json. All we need to do is to write a query file `query1.unq` (the extension is just a convention, and you can choose any name) with the following text:
```
"FirstNames"
```

Assuming `unQLite` is in your search path, you can write:
```shell
unQLite -f query1.unq employee1.json
```

And you'll get the result:
```
"John"
```

For such a simple query, you may want to write the query directly in the command line, instead of storing the query in a file. You can do this with the `-c` option:
```shell
unQLite -c '"FirstName"' employee1.json
```

Note that we use single quotes around the query, so that all the special characters (including the double quotes in this case) would be passed to the program.

But wait! Didn't I just say earlier that each query in ~Q is a json file? This doesn't look very much like json. But in fact, a string literal (in double quotes) is a legal json value. In the simplest cases, where we just want to extract a single value, this is all we need. When we want to extract a specific field, all we need to do is to write the field name in quotes. If the field is in a nested object, we can use the syntax `field1.field2`. For example, try query2.unq:
```
"Address.City"
```
And you'll get the response: `"Austin"`.

Similarly, you can extract information from a specific element inside an array. For example, to get the first name of the first dependant, you can write:
```
"Dependants[0].FirstName"
```

And get the result: `"Jane"`.

Instead of just extracting a single field, we can specify multiple fields we want to extract, as an object:
```
{
  "fullname": "FirstName++' '++LastName",
  "title":"Title",
  "city": "Address.City"
 }
 ```
 
 This looks much more like what we think of as json. And it shows how ~Q can express queries as templates. The result would be:
 ```
 {
    "fullname": "John Smith",
    "title": "CTO",
    "city": "Austin"
}
```

Two things to note here. First, the keys in this object don't have to match the keys in the original json. We renamed `Title` as `title`, etc. Also, notice that we used an expression that connects first and last name into a single string, with the concatenation operator, `++`.

We can also create new nested objects. For example, if we want to group title and salary together inside an "employment" object, we can write the query:
```
{
  "name": "FirstName++' '++LastName",
  "employment": {
     "title":"Title",
     "salary":"Salary"
  }
}
```

=== Collecting information

Suppose we want to collect information from multiple json file. We can try, for example, to run the query `"FirstName"` on all the employees:
```shell
unQLite -c '"FirstName"' *.json
```

Oh no! This is not what we expected. The result is only `"John"` again. What happened to all the other names? Recall that the output 
structure should correspond to the query structure. In this case, we expect to get an array of names. So we need to specify an array in the query
with `[...]`:
```
["FirstName"]
```

Now we get an array with all the first names. In general, an array in ~Q contains a single element, which could be either a string literal or a more complex value (an object, or another array etc.). Once the query is evluated, the array is expended, with new value added each time with process a new file or a new value.


