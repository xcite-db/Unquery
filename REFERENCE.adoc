= ~Q Reference Manual
:sectnums:
Sela Mador-Haim
:toc:

A full reference of the ~Q language.

== Overview

The query language ~Q (Pronounced "unquery") is a query language for structured documents, currently supporting JSON and XML. It is the query language of `XCiteDB`, a structured document database with version control, supporting XML as well as JSON metadata. It is also used in unQuery-lite, a tool for querying and transforming JSON documents. While supporting multiple documents formats as input, the result of ~Q is always represented as JSON. In case of XML, the query results are represented as strings inside a JSON document.

There are two main design principles for ~Q:

* Principle 1: Each ~Q query is a well-formed JSON document.
* Principle 2: The structure of the query result corresponds to the structure of the query itself.

There are few exceptions to those principles. First, we allow c-style comments (both `//` and `/* ... /*`) in ~Q. And second, few language features may violate Principle 2 and create results that may not completely correspond to the query structure.

== Query structure and evaluation

Each query is evaluated by traversing the query from the top node to the leaves in the order they appear in the query. When querying multiple documents, the query is repeatedly evaluated for each document. Objects in ~Q generate corresponding objects in the result. Arrays in ~q generate arrays, and strings contain expressions that are evaluated into JSON values in the result (either a string, or any other value).

=== Strings

A string in ~Q represents an expression. The simplest expressions are paths in the queried JSON document. For example:

* `"Field1"` is the value for the key `Field1`.
* `"Field1.Field2"` is the value of `Field2` within `Field1`
* `"[1]"` is the 2nd element in an array (starting from `0`)
* `"Field1[0]"` is the first element in the array in `Field1`.
* `"Field1[0].Field2"` is the value of `Field2` in the object at the first element in the array in `Field1`.

When a field name includes characters other than alphanumeric characters on underscore, we need to enclose it in backticks. E.g:

```
"`The Second Field`"
```

Note that a path does not have to result in a string value. It can be evaluated to any JSON value, including arrays, objects, and even complex structures such as objects containing arrays of objects etc.

Other basic expressions include constant numbers, bool values, or strings. String constants need to be enclosed in single quotes: `"'A String'"` or escaped quotes: `"\"A String\""`.

We can write more complex expressions with operators. For example `"Field1+Field2"`, use parentheses for presedence. For example: `"(Field1+2)*5"`, and use functions, such as: `"$length(Field1)"` for the length of the string in `Field1`. Functions always start with a `$` sign. We will list all supported operators and functions later in this document.

At the end of the string, after an expression, we may add a predicate, which starts with the symbol `?` followed by a condition. For example: `"Field1?Field2=5"`. Given a predicate, the expression would be evaluated only when the condition is true.

We may also provide sorting specifier for ordering values inside an array. E.g. `"Field1@ascending"`.

=== Arrays

An array in ~Q may contain one or more values. An array in the query evaluates to an array in the result. Each time we evaluate the array in the query (for each document, or multiple times when iterating over elements within the document), we add a new element for the result array.

For example, suppose the query is:
`["FirstName"]`

If we evaluate multiple documents, when one document is for John Doe, the other is for Jane Doe, and the third is for David Gill, the result would be:
`["John","Jane","David"]`

Similarly, if the query is:
`["FirstName","LastName"]`

The result would be:
`["John","Doe","Jane","Doe","David","Gill"]`

=== Objects

Objects in ~Q evaluate to objects in the results. Each object in the query contains pairs of string keys, and values. In the simplest case, constant keys in the querry would correspond to keys with the same name at the result. For example, for the query:
```
{
    "key1":"Field1",
    "key2": "2+5"
}
```

The result would be:
```
{
    "key1":"The value of Field1",
    "key2":"7"
}
```

The keys are evaluated in order. And for each key, the query evalautes the value. Note that when the value is a simple string expression as in the above example, it is evaluated once, and then can no longer change, even if we evaluate the same object again for a different documents. If, for one document, the value of `Field1` is "One value", and for another, the value is "Another value", the result would be just "One value".

Also note that the order of the fields in the result is not guaranteed. While ~Q tries to preserve the order of the fields in an object, the order might not be preserved at some cases, especially when using dynamic key names (See Section ???).

Key names in ~Q are not just constant strings. The language support other types of key names, such as directives (special instructions, starting with `#`, for example, `"#if"`), and dynamic key names which evaluate to one or more key names (for example, `"$(Field1)"`).

Following the key name, ~Q allows a language construct called context modifier (See Section ???).

=== Mixing objects and arrays

~Q allows mixing object and arrays in any possible way. For example, when the query is `[{"key1":"Field1"}]`, the result would be:
```
[{"key1":"value1"}, {"key1","value2"},{"key1":"vale3"}]
```

For the query: `{"key1":["Field1"]}`

The result is:
```
{"key1":["value1","value2","value3"]}
```

And for: `[["Field1"]]`, the result is:
```
[["value1"],["value2"],["value3"]]
```

For the last example, note that there are three entries for the outer array, and a single entry for each inner array. The reason is that each time we evaluate a new document, we add a new entry to the outer array. When we evaluate the second document, we add a new entry to the outer array, so we no longer modify the inner array for the first entry.

Mixing arrays and objects become even more interesting once we use context modifier iterators. For example, the query:
```
{"result:Array1[]": ["Field1"]}
```

Would result in one long array with all the values for `Array1[].Field1` for all documents. e.g.:
```
{"result": ["doc1_value1","doc1_value2","doc2_value1","doc2_value2"]}
```

But if we enclose the entire query in square brackets:
```
[{"result:Array1[]": ["Field1"]}]
```

We would get:
```
[{"result":["doc1_value1","doc1_value2"]},
 {"result":["doc2_value1","doc2_value2"]}]
```

Note that once again, when we use arrays within arrays, the result is that ~Q creates a new object for each document in the outer array, and within each document, it adds new values to the inner array.

== Path expressions

A path expression is used to select a value in a document by specifying the path (i.e. keys and array indexes) from the top. A path in ~Q is relative to the current context path, which is intially the document's root (or top), unless changed with a context modifier.

=== Dot

A `.` (dot) is used to specify the current value. Without any context modifiers, it is the document's root, and would therefore return the entire document. For example:
```
["."]
```

Would return all queried documents as an array. And:
```
{"result:Field1": "."}
```

Is equivalent to:
```
{"result":"Field1"}
```
=== Field name

A field name returns a value corresponding to a key at the current context path. For example: `"Field1"`` would return the value of `Field1`.

When the field name includes spaces or any symbols other than underscore or alphanumeric characters, you need to use backtick. For example:

```
"`Field name with spaces`"
```

=== Subfield

A dot followed by field name (without any spaces between the dot and the key name) extracts a subfield (key for a value). For example: `"Field1.Subfield2"`. 

A subfield extraction operator can be used after an expression, and not just a path. For example: `"$var(x).Subfield1"` extracts the field `Subfield1` from the JSON stored in variable `x`.

The subfield name doesn't have to be a string. We can use an expression an evaluate it to get the key name. For example: `Field1.$(Field2)` would read the value of `Field2` and use the value as the key name to extract.

=== Array element

A number in square brackets, e.g. `[1]`, extracts the corresponding element number from the array (in this case, element `1`, which is the 2nd element). An array element can appear anywhere in a path. For example: `[0].Field1`, or `Field1[0][2].Field2`.

We can use an expession instead of a constant number. For example `Field1[1+1]` or `Field1[$index]`.

=== Whole array

Two square brackets without any number or expression between them returns all of the elements of an array. For example: `Array1[]`. In this case, this would be equivalent to `Array1` without any square brackets, since the value of `Array1` is the entire array.

Hovever, we do need to use the `[]` operator when doing array projection. For example: `Array1[].Field1` would return an array of Field1 value for each object in `Array1`. We could achieve the same effect using content iterators, as in:
```
{"result:Array1[]":["Field1"]}
```

Which is usually preferable since it's more idiomatic for ~Q. But in some cases, array projections are more convenient. For example, when using the `in` operator.

=== Root

In case we changed the current path with a context modifier, we can still access the root element, or any path that starts with the root element (i.e. absolute path) by using a `/` (slash) operator. For example:
```
{"result:Field1": "/Field2"}
```

This would return `Field2` of the top object, and not `Field1.Field2`.

=== Up

The `../` (two dots and slash) operator changes the context to one level up in the path. For example, if the current path is `Field1.Field2`, the path expression `../Field3` returns the value of `Field1.Field3`. Note that the up opator also skips array indexes, so when the path is `Field1.Field2[3]`, the expression: `../Field3` would still return: `Field1.Field3`.

=== Previous document

The `<<` operator would temporary switch back to the previous context, before switching to a different document. For example:
```
{
    "result->$file('another.unq')" : {
        "key1":"Field1",
        "key2":"<<Field1"
    }
}
```

In this case, `key1` would contain the value of `Field1` in `another.unq`, and `key2` would contain the value of `Field1` in the original document.

== Conditions

Conditions are used to filter out results. Conditions can appear in four different places in ~Q:

* <<Predicates>>
* <<if_directive,`#if` directives>>
* <<Constraints,Constrainst on a value>>
* <<if_function,`$if` functions>>

=== Predicates

Predicates appear in a value, after an expression, or in a key, after a context modifier. The syntax is `? condition`. When there is a predicate on a value, the value is evaluated only when the predicate is true. 

When the predicate is false, the expression is skipped. When the predicate appears in a array value, the value won't be added to the array. When a predicate appears in an object, the specific key and value won't be added to the object, but other fields may still be evaluated and added. When a false predicate appears after an aggregate function, the aggregate value won't be updated in this case.

For example:
```
{
   "key1": "value1?x!=1",
   "key2": "value2",
}
```

When `x` is 1, `"key1"` won't appear, but `"key2"` would still be there.

=== Constraints

Constrains have the syntax: `<expression1> <comparator-op> <expression2>`. When used in an array or standalone value, the effect of `"value1 = value2"` (for example) would be the same as `"value1? value1 = value2"`. However, when used in an object field, the entire object won't be evaluated when the constraints are not met. For example:

```
{
    "key1": "value1!=1",
    "key2": "value2>5",
    "key3": "value3"
}
```

This object is evaluated only when both `value1!=1` and `value2>5`. This is equivalent to using the`#if` directive:
```
{
    "#if": "value1!=1 & value2>5"
    "key1": "value1",
    "key2": "value2",
    "key3": "value3"
}
```

=== Equality and inequality operators

We can compare the value of two expressions using equality and inequality operators: `=`, `<`, `>`, `<=`, `>=`, '!='.

For example `x != y`.

=== Negation

We can negate the condition using a `!` before the condition. For example `! x=y` is equivalent to `x!=y`.

=== Exists

An exclamation mark after a field name or path is true only if the field exist in the document. For example: `"Field1.Field2!"` is true when Field2 exists in Field1. This operator can also be used as value constraint. For example:
```
{
    "key1": "Field1!",
    "key2": "value_expr"
}
```

The object is evaluated only when `Field1` exists.

=== Conjunctions and parentheses

The operators `&` (and) and `|` (or) can be used to combine conditions. `&` have higher precedence than `|'. Paretheses are allowed to change the order of precedence. 

For example: `x=5 | (y>7 & x=z)`

=== String conditions

~Q supports the operators `contains`, `starts_with`, `ends_with` and `matches`. Where the first three test if a string contains, starts with or ends with another string, and the last one tests if a string matches a regular expression.

For example: `Field1 contains 'Developer' & Field2 matches 'A.*b'`.

=== Value in array

The operator `in` is true when a value is found inside an array. The operator `not_in` is its negation: `value not_in array` is equivalent to `!(value in array)`.

== Dynamic field names

Keys (field names) can be either a constant string, or an expression that get evaluated to a value (or multiple values, in some cases). A non-constant key is a dynamic value.

=== Constant keys

When a key is an alphanumeric string (including underscores), or enclosed in backticks, it is treated as a constant. The key in the result is the same as the key in the query.

=== Eval expression

When using `$(expression)`, the expression is evaluated, and the resulting value is the key name. For example: 
```
{
   "Field1": "value1",
   "$(Field2)": "value2"
}
```

In this case, the name of the first field would be `"Field1"`, and the name of the second field would be `"Field2"`.

Note that if we evaluate this object multiple times (either for multiple documents, or when using iterators), we would add more fields to the result object. This can be used to construct a dictionary-style object.

Another case where this is useful is when some key values occure multiple times. We can use the pattern:
```
{
    "$(bin)": ["value"]
}
```

The effect would be similar to `group_by` in other query languages. For example, if we have the JSONs:
```
[
    {
        "bin": "One",
        "value": "val1"
    },
    {
        "bin": "Two",
        "value": "val2"
    },
    {
        "bin": "One",
        "value": "val3"
    },
    {
        "bin": "Two",
        "value": "val4"
    },

]
```

And the query:
```
{
    "results:[]": {
        "$(bin)" : ["value"]
    }
}
```

The result would be:
```
{
    "results": {
        "One": ["val1", "val3"],
        "Two": ["val2", "val4"]
    }
}
```

Note that when using function (starting with `$` sign), the `$(...)` is redundant. For example, in the key, we can use `"$index"` instead of `"$($index)"`.

=== Copy keys from queried object

When using `"{}"` as the key, this would be evaluated to all keys in the queried object. For example, when the query is:
```
{
    "{}": "value"
}
```

And the queried object contains `key1`, `key2` and `key3`, the result would be:
```
{
    "key1": "value",
    "key2": "value",
    "key3": "value"
}
```

The value in all three keys is identical here, which is probably rarely useful. A more useful pattern is:

```
{
    "{}:" : "."
}
```

The colon after the `{}` means that the context for each key would be modified accoding to the name of the key, so that `"."` is the value of the corresponding key in each case. The result is copying all keys and their correspond values from the queried objects. This would allow us to copy all fields, and possibly add extra fields to the result.

If we wanted to filter out some fields instead of copying everything, there are several ways we can do that. One is by adding a predicate to the value expression. For example, for copying all fields except `key2`, we can write:
```
{
    "{}:" : ".?$key!='key2'"
}
```

Another syntax we support is:
```
{
    "{'regex'}:" : "."
}
```

This is equivalent to:
```
{
    "{}:" : ".?$key matches 'regex'"
}
```


== Array sorting

== Context modifiers

== Directives

=== #if[[if_directive]]

== Operators

== Functions

=== $if[[if_function]]

== Aggregate functions