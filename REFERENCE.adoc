= ~Q Reference Manual
:sectnums:
Sela Mador-Haim
:toc:

A full reference of the ~Q language.

== Overview

The query language ~Q (Pronounced "unquery") is a query language for structured documents, currently supporting JSON and XML. It is the query language of `XCiteDB`, a structured document database with version control, supporting XML as well as JSON metadata. It is also used in unQuery-lite, a tool for querying and transforming JSON documents. While supporting multiple documents formats as input, the result of ~Q is always represented as JSON. In case of XML, the query results are represented as strings inside a JSON document.

There are two main design principles for ~Q:

* Principle 1: Each ~Q query is a well-formed JSON document.
* Principle 2: The structure of the query result corresponds to the structure of the query itself.

There are few exceptions to those principles. First, we allow c-style comments (both `//` and `/* ... /*`) in ~Q. And second, few language features may violate Principle 2 and create results that may not completely correspond to the query structure.

== Query structure and evaluation

Each query is evaluated by traversing the query from the top node to the leaves in the order they appear in the query. When querying multiple documents, the query is repeatedly evaluated for each document. Objects in ~Q generate corresponding objects in the result. Arrays in ~q generate arrays, and strings contain expressions that are evaluated into JSON values in the result (either a string, or any other value).

=== Strings

A string in ~Q represents an expression. The simplest expressions are paths in the queried JSON document. For example:

* `"Field1"` is the value for the key `Field1`.
* `"Field1.Field2"` is the value of `Field2` within `Field1`
* `"[1]"` is the 2nd element in an array (starting from `0`)
* `"Field1[0]"` is the first element in the array in `Field1`.
* `"Field1[0].Field2"` is the value of `Field2` in the object at the first element in the array in `Field1`.

When a field name includes characters other than alphanumeric characters on underscore, we need to enclose it in backticks. E.g:

```
"`The Second Field`"
```

Note that a path does not have to result in a string value. It can be evaluated to any JSON value, including arrays, objects, and even complex structures such as objects containing arrays of objects etc.

Other basic expressions include constant numbers, bool values, or strings. String constants need to be enclosed in single quotes: `"'A String'"` or escaped quotes: `"\"A String\""`.

We can write more complex expressions with operators. For example `"Field1+Field2"`, use parentheses for presedence. For example: `"(Field1+2)*5"`, and use functions, such as: `"$length(Field1)"` for the length of the string in `Field1`. Functions always start with a `$` sign. We will list all supported operators and functions later in this document.

At the end of the string, after an expression, we may add a predicate, which starts with the symbol `?` followed by a condition. For example: `"Field1?Field2=5"`. Given a predicate, the expression would be evaluated only when the condition is true.

We may also provide sorting specifier for ordering values inside an array. E.g. `"Field1@ascending"`.

=== Arrays

An array in ~Q may contain one or more values. An array in the query evaluates to an array in the result. Each time we evaluate the array in the query (for each document, or multiple times when iterating over elements within the document), we add a new element for the result array.

For example, suppose the query is:
`["FirstName"]`

If we evaluate multiple documents, when one document is for John Doe, the other is for Jane Doe, and the third is for David Gill, the result would be:
`["John","Jane","David"]`

Similarly, if the query is:
`["FirstName","LastName"]`

The result would be:
`["John","Doe","Jane","Doe","David","Gill"]`

=== Objects

Objects in ~Q evaluate to objects in the results. Each object in the query contains pairs of string keys, and values. In the simplest case, constant keys in the querry would correspond to keys with the same name at the result. For example, for the query:
```
{
    "key1":"Field1",
    "key2": "2+5"
}
```

The result would be:
```
{
    "key1":"The value of Field1",
    "key2":"7"
}
```

The keys are evaluated in order. And for each key, the query evalautes the value. Note that when the value is a simple string expression as in the above example, it is evaluated once, and then can no longer change, even if we evaluate the same object again for a different documents. If, for one document, the value of `Field1` is "One value", and for another, the value is "Another value", the result would be just "One value".

Also note that the order of the fields in the result is not guaranteed. While ~Q tries to preserve the order of the fields in an object, the order might not be preserved at some cases, especially when using dynamic key names (See Section ???).

Key names in ~Q are not just constant strings. The language support other types of key names, such as directives (special instructions, starting with `#`, for example, `"#if"`), and dynamic key names which evaluate to one or more key names (for example, `"$(Field1)"`).

Following the key name, ~Q allows a language construct called context modifier (See Section ???).

=== Mixing objects and arrays

~Q allows mixing object and arrays in any possible way. For example, when the query is `[{"key1":"Field1"}]`, the result would be:
```
[{"key1":"value1"}, {"key1","value2"},{"key1":"vale3"}]
```

For the query: `{"key1":["Field1"]}`

The result is:
```
{"key1":["value1","value2","value3"]}
```

And for: `[["Field1"]]`, the result is:
```
[["value1"],["value2"],["value3"]]
```

For the last example, note that there are three entries for the outer array, and a single entry for each inner array. The reason is that each time we evaluate a new document, we add a new entry to the outer array. When we evaluate the second document, we add a new entry to the outer array, so we no longer modify the inner array for the first entry.

Mixing arrays and objects become even more interesting once we use context modifier iterators. For example, the query:
```
{"result:Array1[]": ["Field1"]}
```

Would result in one long array with all the values for `Array1[].Field1` for all documents. e.g.:
```
{"result": ["doc1_value1","doc1_value2","doc2_value1","doc2_value2"]}
```

But if we enclose the entire query in square brackets:
```
[{"result:Array1[]": ["Field1"]}]
```

We would get:
```
[{"result":["doc1_value1","doc1_value2"]},
 {"result":["doc2_value1","doc2_value2"]}]
```

Note that once again, when we use arrays within arrays, the result is that ~Q creates a new object for each document in the outer array, and within each document, it adds new values to the inner array.

== Path expressions

A path expression is used to select a value in a document by specifying the path (i.e. keys and array indexes) from the top. A path in ~Q is relative to the current context path, which is intially the document's root (or top), unless changed with a context modifier.

=== Dot

A `.` (dot) is used to specify the current value. Without any context modifiers, it is the document's root, and would therefore return the entire document. For example:
```
["."]
```

Would return all queried documents as an array. And:
```
{"result:Field1": "."}
```

Is equivalent to:
```
{"result":"Field1"}
```
=== Field name

A field name returns a value corresponding to a key at the current context path. For example: `"Field1"`` would return the value of `Field1`.

When the field name includes spaces or any symbols other than underscore or alphanumeric characters, you need to use backtick. For example:

```
"`Field name with spaces`"
```

=== Subfield

A dot followed by field name (without any spaces between the dot and the key name) extracts a subfield (key for a value). For example: `"Field1.Subfield2"`. 

A subfield extraction operator can be used after an expression, and not just a path. For example: `"$var(x).Subfield1"` extracts the field `Subfield1` from the JSON stored in variable `x`.

The subfield name doesn't have to be a string. We can use an expression an evaluate it to get the key name. For example: `Field1.$(Field2)` would read the value of `Field2` and use the value as the key name to extract.

=== Array element

A number in square brackets, e.g. `[1]`, extracts the corresponding element number from the array (in this case, element `1`, which is the 2nd element). An array element can appear anywhere in a path. For example: `[0].Field1`, or `Field1[0][2].Field2`.

We can use an expession instead of a constant number. For example `Field1[1+1]` or `Field1[$index]`.

=== Whole array

Two square brackets without any number or expression between them returns all of the elements of an array. For example: `Array1[]`. In this case, this would be equivalent to `Array1` without any square brackets, since the value of `Array1` is the entire array.

Hovever, we do need to use the `[]` operator when doing array projection. For example: `Array1[].Field1` would return an array of Field1 value for each object in `Array1`. We could achieve the same effect using content iterators, as in:
```
{"result:Array1[]":["Field1"]}
```

Which is usually preferable since it's more idiomatic for ~Q. But in some cases, array projections are more convenient. For example, when using the `in` operator.

=== Root

In case we changed the current path with a context modifier, we can still access the root element, or any path that starts with the root element (i.e. absolute path) by using a `/` (slash) operator. For example:
```
{"result:Field1": "/Field2"}
```

This would return `Field2` of the top object, and not `Field1.Field2`.

=== Up

The `../` (two dots and slash) operator changes the context to one level up in the path. For example, if the current path is `Field1.Field2`, the path expression `../Field3` returns the value of `Field1.Field3`. Note that the up opator also skips array indexes, so when the path is `Field1.Field2[3]`, the expression: `../Field3` would still return: `Field1.Field3`.

== Conditions

== Dynamic field names

== Array sorting

== Context modifiers

== Directives

== Operators

== Functions
